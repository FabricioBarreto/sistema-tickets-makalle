

===== app/api/tickets/route.ts =====

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { generateQRHash, generateReadableCode } from "@/lib/crypto";

// GET - Listar tickets (admin)
export async function GET() {
  try {
    const tickets = await prisma.ticket.findMany({
      orderBy: { createdAt: "desc" },
      include: {
        order: true,
        validations: {
          orderBy: { timestamp: "desc" },
          take: 1,
          include: {
            user: { select: { name: true } },
          },
        },
      },
    });

    const formatted = tickets.map((t) => {
      const lastValidation = t.validations[0] ?? null;

      const validated = t.status === "VALIDATED" || !!t.validatedAt;

      return {
        id: t.id,
        code: t.code,
        orderNumber: t.order.orderNumber,
        buyerName: t.order.buyerName,
        buyerEmail: t.order.buyerEmail,
        buyerDNI: t.order.buyerDNI ?? "",
        quantity: t.order.quantity,
        price: t.order.unitPrice.toString(),
        validated,
        validatedAt: t.validatedAt?.toISOString?.() ?? null,
        purchaseDate: t.order.purchaseDate.toISOString(),
        paymentStatus: t.order.paymentStatus,
        validatedBy: lastValidation
          ? { name: lastValidation.user.name }
          : validated
            ? { name: "Desconocido" }
            : null,
      };
    });

    return NextResponse.json({ success: true, tickets: formatted });
  } catch (error) {
    console.error("GET /api/tickets error:", error);
    return NextResponse.json(
      { success: false, error: "Error al obtener tickets" },
      { status: 500 },
    );
  }
}

// POST - Crear nueva orden con tickets
export async function POST(req: NextRequest) {
  // üö® DEBUG: LOGGING TEMPORAL PARA IDENTIFICAR ATACANTE
  const clientIP =
    req.headers.get("x-forwarded-for") ||
    req.headers.get("x-real-ip") ||
    req.headers.get("cf-connecting-ip") ||
    "unknown";

  const debugInfo = {
    timestamp: new Date().toISOString(),
    ip: clientIP,
    userAgent: req.headers.get("user-agent") || "none",
    referer: req.headers.get("referer") || "none",
    origin: req.headers.get("origin") || "none",
    cfCountry: req.headers.get("cf-ipcountry") || "unknown",
    cfRay: req.headers.get("cf-ray") || "none",
    host: req.headers.get("host"),
    acceptLanguage: req.headers.get("accept-language") || "none",
  };

  console.log(
    "üö® POST /api/tickets REQUEST:",
    JSON.stringify(debugInfo, null, 2),
  );
  // FIN DEBUG

  try {
    const body = await req.json();
    const { buyerName, buyerEmail, buyerPhone, quantity } = body;

    // üö® DEBUG: Log del contenido del request
    console.log("üö® REQUEST BODY:", {
      buyerName,
      buyerEmail,
      buyerPhone,
      quantity,
      ip: clientIP,
    });

    // ‚úÖ Validaci√≥n b√°sica
    if (!buyerName || !buyerEmail || !quantity) {
      console.log("‚õî BLOCKED: Missing required fields from IP:", clientIP);
      return NextResponse.json(
        { success: false, error: "Faltan datos requeridos" },
        { status: 400 },
      );
    }

    // ‚úÖ SEGURIDAD 1: Bloquear emails de prueba en producci√≥n
    if (process.env.NODE_ENV === "production") {
      const testDomains = [
        "@example.com",
        "@test.com",
        "@testing.com",
        "@mail.com",
        "@temp-mail",
        "@throwaway",
        "@guerrillamail",
        "@10minutemail",
      ];

      const isTestEmail = testDomains.some((domain) =>
        buyerEmail.toLowerCase().includes(domain),
      );

      if (isTestEmail) {
        console.log(
          `‚õî BLOCKED test email: ${buyerEmail} from IP: ${clientIP}`,
        );
        return NextResponse.json(
          {
            success: false,
            error:
              "Email de prueba no permitido. Por favor usa un email v√°lido.",
          },
          { status: 400 },
        );
      }
    }

    // ‚úÖ SEGURIDAD 2: Validar formato de email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(buyerEmail)) {
      console.log(
        `‚õî BLOCKED invalid email: ${buyerEmail} from IP: ${clientIP}`,
      );
      return NextResponse.json(
        { success: false, error: "Formato de email inv√°lido" },
        { status: 400 },
      );
    }

    // ‚úÖ SEGURIDAD 3: Validar longitud de nombre
    if (buyerName.length < 3 || buyerName.length > 100) {
      console.log(`‚õî BLOCKED invalid name length from IP: ${clientIP}`);
      return NextResponse.json(
        { success: false, error: "Nombre inv√°lido" },
        { status: 400 },
      );
    }

    // ‚úÖ SEGURIDAD 4: Validar cantidad
    if (quantity < 1 || quantity > 50) {
      console.log(
        `‚õî BLOCKED invalid quantity: ${quantity} from IP: ${clientIP}`,
      );
      return NextResponse.json(
        { success: false, error: "Cantidad inv√°lida" },
        { status: 400 },
      );
    }

    const normalizedPhone =
      typeof buyerPhone === "string" && buyerPhone.trim().length > 0
        ? buyerPhone.trim()
        : null;

    const config = await prisma.systemConfig.findFirst();
    if (!config) {
      return NextResponse.json(
        { success: false, error: "Configuraci√≥n del sistema no encontrada" },
        { status: 500 },
      );
    }

    if (!config.salesEnabled) {
      console.log(`‚õî BLOCKED: Sales disabled - IP: ${clientIP}`);
      return NextResponse.json(
        { success: false, error: "Las ventas est√°n cerradas" },
        { status: 400 },
      );
    }

    const soldCount = await prisma.ticket.count({
      where: { status: { in: ["PAID", "VALIDATED"] } },
    });

    const available = config.totalAvailable - soldCount;
    if (available < quantity) {
      console.log(`‚õî BLOCKED: Insufficient tickets - IP: ${clientIP}`);
      return NextResponse.json(
        {
          success: false,
          error: `Solo quedan ${available} entradas disponibles`,
        },
        { status: 400 },
      );
    }

    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8).toUpperCase();
    const orderNumber = `ORD-${timestamp}-${random}`;

    const unitPrice = Number(config.ticketPrice);
    const totalAmount = unitPrice * quantity;

    const order = await prisma.order.create({
      data: {
        orderNumber,
        buyerName,
        buyerEmail,
        buyerPhone: normalizedPhone,
        unitPrice,
        quantity,
        totalAmount,
        paymentStatus: "PENDING",
        status: "ACTIVE",
      },
    });

    const tickets = [];
    for (let i = 0; i < quantity; i++) {
      const code = generateReadableCode(orderNumber, i);
      const qrHash = await generateQRHash(order.id, i);

      const ticket = await prisma.ticket.create({
        data: {
          orderId: order.id,
          code,
          qrHash,
          status: "PENDING_PAYMENT",
        },
      });

      tickets.push(ticket);
    }

    // üö® DEBUG: Log de orden exitosa
    console.log(
      `‚úÖ Order created: ${orderNumber} - ${buyerEmail} - IP: ${clientIP} - Country: ${debugInfo.cfCountry}`,
    );

    return NextResponse.json({
      success: true,
      data: {
        id: order.id,
        orderNumber: order.orderNumber,
        totalAmount: Number(order.totalAmount),
        quantity: order.quantity,
        tickets: tickets.map((t) => ({
          id: t.id,
          code: t.code,
          qrHash: t.qrHash,
        })),
      },
    });
  } catch (error: unknown) {
    console.error("Error creating order:", error);
    console.log("üö® ERROR from IP:", clientIP);
    const errorMessage =
      error instanceof Error ? error.message : "Error al crear la orden";
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 },
    );
  }
}


===== app/api/unicobros/webhook/route.ts =====

// app/api/unicobros/webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { TicketStatus } from "@prisma/client";
import crypto from "crypto";
import {
  mapMPStatusToInternal,
  mapMPStatusToPaymentStatus,
} from "@/lib/unicobros";
import { sendTicketWhatsAppTwilio } from "@/lib/whatsapp-twilio";
import { sendTicketEmailWithGmail as sendTicketEmailWithQRs } from "@/lib/email-gmail";

interface WebhookPayment {
  id: string | number;
  reference: string;
  status?: {
    code: string;
  };
}

interface WebhookData {
  payment: WebhookPayment;
}

interface WebhookBody {
  type: string;
  data: WebhookData;
}

// ‚úÖ RATE LIMITING GLOBAL AGRESIVO
let lastProcessedTime = 0;
const GLOBAL_RATE_LIMIT_MS = 1000; // 1 segundo entre webhooks
const processedPayments = new Map<string, number>(); // Cache de payments procesados

function generateDownloadToken(): string {
  return crypto.randomBytes(32).toString("hex");
}

function checkGlobalRateLimit(): boolean {
  const now = Date.now();
  if (now - lastProcessedTime < GLOBAL_RATE_LIMIT_MS) {
    return false; // Demasiado r√°pido
  }
  lastProcessedTime = now;
  return true;
}

export async function POST(request: NextRequest) {
  try {
    // ‚úÖ RATE LIMIT GLOBAL (1 req/segundo para TODO)
    if (!checkGlobalRateLimit()) {
      return new NextResponse(null, { status: 200 });
    }

    const rawBody: unknown = await request.json();

    // Validar estructura b√°sica
    if (
      !rawBody ||
      typeof rawBody !== "object" ||
      !("type" in rawBody) ||
      !("data" in rawBody)
    ) {
      return new NextResponse(null, { status: 200 });
    }

    const body = rawBody as WebhookBody;

    // ‚úÖ FILTRO 1: Solo tipo "checkout"
    if (body.type !== "checkout") {
      console.log(`‚è≠Ô∏è Tipo: ${body.type}`);
      return new NextResponse(null, { status: 200 });
    }

    const webhookData = body.data;
    const payment = webhookData?.payment;

    // ‚úÖ FILTRO 2: Validar datos completos
    if (!payment || !payment.id || !payment.reference) {
      return new NextResponse(null, { status: 200 });
    }

    const paymentId = String(payment.id);
    const orderId = payment.reference;
    const statusCode = payment.status?.code || "0";
    const statusNum = parseInt(statusCode, 10);

    // ‚úÖ FILTRO 3: Solo procesar status 200 (aprobado)
    if (statusNum !== 200) {
      console.log(`‚è≠Ô∏è Status: ${statusCode}`);
      return new NextResponse(null, { status: 200 });
    }

    // ‚úÖ FILTRO 4: Cache en memoria (evitar procesar el mismo payment m√∫ltiples veces)
    const cacheKey = `${paymentId}-${orderId}`;
    const lastProcessed = processedPayments.get(cacheKey);
    const now = Date.now();

    if (lastProcessed && now - lastProcessed < 300000) {
      // 5 minutos
      console.log(
        `‚è≠Ô∏è Ya procesado: ${paymentId} (hace ${Math.round((now - lastProcessed) / 1000)}s)`,
      );
      return new NextResponse(null, { status: 200 });
    }

    console.log("üîî Webhook v√°lido:", {
      paymentId,
      orderId,
      statusCode,
      timestamp: new Date().toISOString(),
    });

    // ‚úÖ FILTRO 5: Verificar en DB si ya procesamos este pago
    const existingOrder = await prisma.order.findFirst({
      where: {
        mercadoPagoId: paymentId,
        paymentStatus: "COMPLETED",
      },
      select: { id: true, orderNumber: true },
    });

    if (existingOrder) {
      console.log(`‚è≠Ô∏è Ya procesado en DB: ${existingOrder.orderNumber}`);
      processedPayments.set(cacheKey, now); // Guardar en cache
      return new NextResponse(null, { status: 200 });
    }

    // Buscar orden
    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: { tickets: true },
    });

    if (!order || !order.tickets || order.tickets.length === 0) {
      console.error("‚ùå Orden no encontrada:", orderId);
      return new NextResponse(null, { status: 200 });
    }

    console.log(
      `üé´ Orden: ${order.orderNumber} (${order.tickets.length} tickets)`,
    );

    // Mapear status
    const ticketStatus = mapMPStatusToInternal(statusNum) as TicketStatus;
    const paymentStatus = mapMPStatusToPaymentStatus(statusNum);

    // ‚úÖ FILTRO 6: Anti-downgrade
    if (order.paymentStatus === "COMPLETED" && paymentStatus !== "COMPLETED") {
      console.log(`üõ°Ô∏è Anti-downgrade: ${order.orderNumber}`);
      processedPayments.set(cacheKey, now);
      return new NextResponse(null, { status: 200 });
    }

    // Generar token si no existe
    let downloadToken = order.downloadToken;
    if (!downloadToken) {
      downloadToken = generateDownloadToken();
    }

    // ‚úÖ MARCAR COMO PROCESADO EN CACHE ANTES DE ACTUALIZAR DB
    processedPayments.set(cacheKey, now);

    // Limpiar cache viejo (> 1 hora)
    if (processedPayments.size > 500) {
      const oneHourAgo = now - 3600000;
      for (const [key, time] of processedPayments.entries()) {
        if (time < oneHourAgo) {
          processedPayments.delete(key);
        }
      }
    }

    // Actualizar orden
    await prisma.order.update({
      where: { id: order.id },
      data: {
        paymentStatus,
        mercadoPagoId: paymentId,
        mercadoPagoStatus: statusCode,
        downloadToken,
      },
    });

    // Actualizar tickets
    await prisma.ticket.updateMany({
      where: { orderId: order.id },
      data: { status: ticketStatus },
    });

    console.log(`‚úÖ Orden actualizada: ${order.orderNumber}`);

    // üéâ ENV√çO AUTOM√ÅTICO DE TICKETS
    console.log("üí≥ Enviando notificaciones...");

    const config = await prisma.systemConfig.findFirst();
    const eventName = config?.eventName || "Carnavales Makall√© 2026";
    const eventDate =
      config?.eventDate?.toLocaleDateString("es-AR", {
        day: "numeric",
        month: "long",
        year: "numeric",
      }) || "Febrero 2026";
    const eventLocation = config?.eventLocation || "Makall√©, Chaco";

    const rawUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
    const baseUrl = rawUrl.replace(/\/+$/, "");
    const downloadUrl = `${baseUrl}/api/tickets/download/${downloadToken}`;

    const ticketsData = order.tickets.map((ticket) => ({
      id: ticket.id,
      qrCode: ticket.qrHash,
      order: {
        orderNumber: order.orderNumber,
        buyerName: order.buyerName,
      },
    }));

    let emailSent = false;
    let whatsappSent = false;

    // üìß ENVIAR EMAIL
    try {
      const emailResult = await sendTicketEmailWithQRs({
        to: order.buyerEmail,
        orderNumber: order.orderNumber,
        buyerName: order.buyerName,
        tickets: ticketsData,
        eventName,
        eventDate,
        eventLocation,
        downloadUrl,
      });

      if (emailResult.success) {
        emailSent = true;
        console.log(`‚úÖ Email ‚Üí ${order.buyerEmail}`);
      } else {
        console.error(`‚ùå Email fall√≥: ${emailResult.error}`);
      }
    } catch (err: unknown) {
      console.error("‚ùå Email error:", err);
    }

    // üì± ENVIAR WHATSAPP
    if (order.buyerPhone) {
      try {
        if (!process.env.TWILIO_ACCOUNT_SID || !process.env.TWILIO_AUTH_TOKEN) {
          console.log("‚ö†Ô∏è Twilio no configurado");
        } else if (!process.env.TWILIO_CONTENT_SID) {
          console.log("‚ö†Ô∏è Template no configurado");
        } else {
          let normalizedPhone = order.buyerPhone.replace(/[^0-9+]/g, "");
          if (!normalizedPhone.startsWith("+")) {
            normalizedPhone = "+54" + normalizedPhone;
          }

          const whatsappResult = await sendTicketWhatsAppTwilio({
            to: normalizedPhone,
            buyerName: order.buyerName,
            eventName,
            eventDate,
            eventLocation,
            orderNumber: order.orderNumber,
            ticketCount: order.tickets.length,
            downloadUrl,
          });

          if (whatsappResult.success) {
            whatsappSent = true;
            console.log(`‚úÖ WhatsApp ‚Üí ${normalizedPhone}`);
          }
        }
      } catch (err: unknown) {
        console.log("‚ö†Ô∏è WhatsApp error:", err);
      }
    }

    // üìä RESUMEN
    console.log("üìä", {
      email: emailSent ? "‚úÖ" : "‚ùå",
      whatsapp: whatsappSent ? "‚úÖ" : "‚è≠Ô∏è",
      download: downloadUrl,
    });

    return NextResponse.json({
      received: true,
      processed: true,
      orderId: order.id,
      emailSent,
      whatsappSent,
    });
  } catch (error: unknown) {
    console.error("‚ùå Webhook error:", error);
    return new NextResponse(null, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({
    status: "active",
    message: "Unicobros webhook endpoint with rate limiting",
    version: "3.1",
    timestamp: new Date().toISOString(),
  });
}


===== app/api/mercadopago/webhook/route.ts =====

import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { TicketStatus } from "@prisma/client";
import crypto from "crypto";
import {
  getPaymentStatus,
  mapMPStatusToInternal,
  mapMPStatusToPaymentStatus,
} from "@/lib/mercadopago";
import { sendTicketEmailWithQRs } from "@/lib/email";
import { sendTicketWhatsAppTwilio } from "@/lib/whatsapp-twilio";

interface MPPaymentData {
  id?: number;
  status: string;
  external_reference?: string;
}

function generateDownloadToken(): string {
  return crypto.randomBytes(32).toString("hex");
}

type WebhookBody = {
  type?: string;
  data?: { id?: string | number };
};

export async function POST(request: NextRequest) {
  try {
    const rawBody: unknown = await request.json();
    const body = rawBody as WebhookBody;

    console.log("üîî Webhook received:", JSON.stringify(body, null, 2));

    if (body.type !== "payment") {
      return NextResponse.json({ received: true });
    }

    const paymentId = body.data?.id;
    if (paymentId === undefined || paymentId === null) {
      return NextResponse.json({ received: true });
    }

    const paymentIdStr = String(paymentId);
    console.log(`üí≥ Processing payment ID: ${paymentIdStr}`);

    const paymentInfo = await getPaymentStatus(paymentIdStr);

    if (!paymentInfo.success) {
      console.error("‚ùå Failed to get payment info:", paymentInfo.error);
      return NextResponse.json({ received: true });
    }

    const payment = paymentInfo.payment as MPPaymentData;
    const orderId = payment.external_reference;

    if (!orderId) {
      console.error("‚ùå No external reference found in payment");
      return NextResponse.json({ received: true });
    }

    console.log(`üì¶ Processing order ID: ${orderId}`);

    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: { tickets: true },
    });

    if (!order || !order.tickets || order.tickets.length === 0) {
      console.error("‚ùå Order not found or has no tickets:", orderId);
      return NextResponse.json({ received: true });
    }

    console.log(`üé´ Found order with ${order.tickets.length} tickets`);

    const ticketStatus = mapMPStatusToInternal(payment.status) as TicketStatus;
    const paymentStatus = mapMPStatusToPaymentStatus(payment.status);

    let downloadToken = order.downloadToken;
    if (!downloadToken) {
      downloadToken = generateDownloadToken();
    }

    await prisma.order.update({
      where: { id: order.id },
      data: {
        paymentStatus,
        mercadoPagoId: payment.id?.toString(),
        mercadoPagoStatus: payment.status,
        downloadToken,
      },
    });

    await prisma.ticket.updateMany({
      where: { orderId: order.id },
      data: { status: ticketStatus },
    });

    console.log(`‚úÖ Updated order and tickets - Status: ${ticketStatus}`);

    if (payment.status === "approved") {
      console.log("üí≥ Payment approved! Sending notifications...");

      const config = await prisma.systemConfig.findFirst();
      const eventName = config?.eventName || "Carnavales Makall√© 2026";
      const eventDate =
        config?.eventDate?.toLocaleDateString("es-AR", {
          day: "numeric",
          month: "long",
          year: "numeric",
        }) || "Febrero 2026";
      const eventLocation = config?.eventLocation || "Makall√©, Chaco";

      const rawUrl = process.env.NEXT_PUBLIC_APP_URL || "http://localhost:3000";
      const baseUrl = rawUrl.replace(/\/+$/, "");
      const downloadUrl = `${baseUrl}/api/tickets/download/${downloadToken}`;

      const ticketsData = order.tickets.map((ticket) => ({
        id: ticket.id,
        qrCode: ticket.qrHash,
        order: {
          orderNumber: order.orderNumber,
          buyerName: order.buyerName,
        },
      }));

      let emailSent = false;
      let whatsappSent = false;

      console.log("[notifications] üìß Attempting EMAIL delivery...");
      try {
        const emailResult = await sendTicketEmailWithQRs({
          to: order.buyerEmail,
          orderNumber: order.orderNumber,
          buyerName: order.buyerName,
          tickets: ticketsData,
          eventName,
          eventDate,
          eventLocation,
          downloadUrl,
        });

        if (emailResult.success) {
          emailSent = true;
          console.log(`‚úÖ EMAIL sent successfully to ${order.buyerEmail}`);
          console.log(`üìß Message ID: ${emailResult.messageId}`);
        } else {
          console.error(
            `‚ùå EMAIL failed to ${order.buyerEmail}:`,
            emailResult.error,
          );
        }
      } catch (err: unknown) {
        console.error("‚ùå EMAIL exception", err);
      }

      if (order.buyerPhone) {
        console.log("[notifications] üì± Attempting WhatsApp delivery...");

        try {
          if (
            !process.env.TWILIO_ACCOUNT_SID ||
            !process.env.TWILIO_AUTH_TOKEN
          ) {
            console.log(
              "‚ö†Ô∏è  WhatsApp: Twilio credentials not configured, skipping",
            );
          } else if (!process.env.TWILIO_CONTENT_SID) {
            console.log(
              "‚ö†Ô∏è  WhatsApp: Template not configured (waiting for Meta approval), skipping",
            );
          } else {
            // üëá NORMALIZAR TEL√âFONO
            let normalizedPhone = order.buyerPhone.replace(/[^0-9+]/g, "");
            if (!normalizedPhone.startsWith("+")) {
              normalizedPhone = "+54" + normalizedPhone;
            }
            console.log(
              `üì± Normalized phone: ${order.buyerPhone} ‚Üí ${normalizedPhone}`,
            );

            const whatsappResult = await sendTicketWhatsAppTwilio({
              to: normalizedPhone, // üëà Usar tel√©fono normalizado
              buyerName: order.buyerName,
              eventName,
              eventDate,
              eventLocation,
              orderNumber: order.orderNumber,
              ticketCount: order.tickets.length,
              downloadUrl,
            });

            if (whatsappResult.success) {
              whatsappSent = true;
              console.log(
                `‚úÖ WhatsApp sent successfully to ${normalizedPhone}`,
              );
              console.log(`üì± Message SID: ${whatsappResult.messageId}`);
            } else {
              console.log(
                `‚ö†Ô∏è  WhatsApp failed to ${normalizedPhone}: ${whatsappResult.error}`,
              );
            }
          }
        } catch (err: unknown) {
          console.log("‚ö†Ô∏è  WhatsApp exception (not critical)", err);
        }
      } else {
        console.log("‚ÑπÔ∏è  No phone number provided, skipping WhatsApp");
      }

      console.log("\nüìä Notification Summary:");
      console.log(`   üìß Email: ${emailSent ? "‚úÖ Sent" : "‚ùå Failed"}`);
      console.log(
        `   üì± WhatsApp: ${
          whatsappSent
            ? "‚úÖ Sent"
            : order.buyerPhone
              ? "‚ö†Ô∏è  Skipped/Failed"
              : "‚è≠Ô∏è  No phone"
        }`,
      );
      console.log(`   üîó Download link: ${downloadUrl}\n`);

      if (!emailSent) {
        console.error(
          "‚ö†Ô∏è  WARNING: EMAIL delivery failed - customer will need to use download link",
        );
      }
    } else {
      console.log(
        `‚è∏Ô∏è  Payment status is ${payment.status}, not sending notifications yet`,
      );
    }

    return NextResponse.json({ received: true });
  } catch (error: unknown) {
    console.error("‚ùå Webhook error:", error);
    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";
    return NextResponse.json({ received: true, error: errorMessage });
  }
}

export async function GET() {
  return NextResponse.json({
    status: "active",
    message: "Mercado Pago webhook endpoint",
  });
}

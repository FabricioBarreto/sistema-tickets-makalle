"use client";

import { useEffect, useState, useRef } from "react";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { QRScanner } from "@/components/QRScanner";
import {
  CheckCircle2,
  XCircle,
  AlertCircle,
  User,
  Hash,
  Calendar,
  ShieldCheck,
  LogOut,
  Loader2,
  Smartphone,
  Zap,
} from "lucide-react";
import { Button } from "@/components/ui/button";

interface TicketInfo {
  id: string;
  orderNumber: string;
  buyerName: string;
  buyerEmail: string;
  buyerDNI?: string;
  quantity: number;
  validated: boolean;
  validatedAt?: Date;
  validatedBy?: { name: string };
}

type ScanStatus =
  | "idle"
  | "validating"
  | "success"
  | "error"
  | "already-used"
  | "payment-pending";

export default function ValidatePage() {
  const { data: session, status } = useSession();
  const router = useRouter();

  const [scanStatus, setScanStatus] = useState<ScanStatus>("idle");
  const [message, setMessage] = useState("");
  const [ticketInfo, setTicketInfo] = useState<TicketInfo | null>(null);
  const [validationCount, setValidationCount] = useState(0);

  // üî• CLAVE: controla si la c√°mara est√° prendida o apagada
  const [scannerEnabled, setScannerEnabled] = useState(true);

  // Anti-spam extra (por si alg√∫n browser se pone loco)
  const lastScanTimeRef = useRef(0);

  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/operador/login");
    }
  }, [status, router]);

  async function validateCode(code: string) {
    const response = await fetch("/api/tickets/validate", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ qrCode: code }),
    });

    const data = await response.json().catch(() => ({}));
    return { response, data };
  }

  const handleScan = async (decodedText: string) => {
    // üß® BLOQUEO TOTAL DE LOOP
    if (!scannerEnabled) return;
    if (scanStatus === "validating") return;

    // Cooldown hard (mobile safety)
    const now = Date.now();
    if (now - lastScanTimeRef.current < 1500) return;
    lastScanTimeRef.current = now;

    // üî• APAGAMOS LA C√ÅMARA INMEDIATAMENTE
    setScannerEnabled(false);
    setScanStatus("validating");
    setMessage("Verificando entrada...");
    setTicketInfo(null);

    try {
      const { response, data } = await validateCode(decodedText);

      if (response.ok && data.success) {
        setScanStatus("success");
        setMessage("‚úÖ Entrada validada correctamente");
        setTicketInfo(data.ticket);
        setValidationCount((prev) => prev + 1);
        return;
      }

      if (response.status === 409 && data?.error === "PAYMENT_PENDING") {
        setScanStatus("payment-pending");
        setMessage("‚è≥ Pago pendiente: todav√≠a no fue confirmado");
        setTicketInfo(data.ticket ?? null);
        return;
      }

      if (data.message?.includes("ya fue utilizada")) {
        setScanStatus("already-used");
        setMessage("‚ö†Ô∏è Entrada ya utilizada anteriormente");
        setTicketInfo(data.ticket);
        return;
      }

      setScanStatus("error");
      setMessage(data.message || "Error al validar la entrada");
    } catch {
      setScanStatus("error");
      setMessage("Error de conexi√≥n. Intenta nuevamente.");
    }
  };

  // üîÅ Reintentar MISMO QR (pago pendiente)
  const retryScan = () => {
    setScanStatus("idle");
    setMessage("");
    setTicketInfo(null);
    setScannerEnabled(true);
  };

  // üîÑ Escanear otro QR
  const resetScan = () => {
    setScanStatus("idle");
    setMessage("");
    setTicketInfo(null);
    setScannerEnabled(true);
  };

  const handleLogout = async () => {
    await fetch("/api/auth/signout", { method: "POST" });
    router.push("/operador/login");
  };

  if (status === "loading") {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="h-12 w-12 animate-spin" />
      </div>
    );
  }

  if (!session) return null;

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-600 via-pink-600 to-red-600">
      {/* HEADER */}
      <div className="bg-white shadow sticky top-0 z-50">
        <div className="max-w-2xl mx-auto px-4 py-3 flex justify-between items-center">
          <div className="flex gap-3 items-center">
            <ShieldCheck className="text-purple-600" />
            <div>
              <h1 className="font-black">Validador QR</h1>
              <p className="text-xs">{session.user.name}</p>
            </div>
          </div>
          <Button variant="outline" size="sm" onClick={handleLogout}>
            <LogOut className="h-4 w-4" />
          </Button>
        </div>
      </div>

      {/* CONTENIDO */}
      <div className="max-w-2xl mx-auto p-4 space-y-6">
        {/* SCANNER */}
        <div className="bg-white rounded-xl shadow p-4">
          {scannerEnabled ? (
            <QRScanner
              onScan={handleScan}
              onError={(err) => {
                setScanStatus("error");
                setMessage(err);
                setScannerEnabled(false);
              }}
            />
          ) : (
            <div className="text-center text-gray-500 py-10">
              C√°mara pausada
            </div>
          )}
        </div>

        {/* RESULTADO */}
        {scanStatus !== "idle" && (
          <div className="bg-white rounded-xl shadow p-4 space-y-4">
            <h2 className="font-bold text-lg">{message}</h2>

            {ticketInfo && (
              <div className="space-y-2 text-sm">
                <p>
                  <strong>Comprador:</strong> {ticketInfo.buyerName}
                </p>
                <p>
                  <strong>Orden:</strong> #{ticketInfo.orderNumber}
                </p>
              </div>
            )}

            {scanStatus === "payment-pending" ? (
              <Button
                onClick={retryScan}
                className="w-full bg-orange-500 hover:bg-orange-600"
              >
                Reintentar
              </Button>
            ) : (
              <Button
                onClick={resetScan}
                className="w-full bg-purple-600 hover:bg-purple-700"
              >
                Escanear siguiente
              </Button>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json(
        { success: false, message: "No autorizado" },
        { status: 401 },
      );
    }

    const { qrCode } = await req.json();

    if (!qrCode) {
      return NextResponse.json(
        { success: false, message: "C√≥digo QR requerido" },
        { status: 400 },
      );
    }

    const code = String(qrCode).trim();

    // Buscar el ticket por QR hash o c√≥digo manual
    const ticket = await prisma.ticket.findFirst({
      where: {
        OR: [{ qrHash: code }, { code }],
      },
      include: {
        order: {
          select: {
            orderNumber: true,
            buyerName: true,
            buyerEmail: true,
            buyerPhone: true,
            buyerDNI: true,
            unitPrice: true,
            quantity: true,
            paymentStatus: true,
            mercadoPagoStatus: true, // (en tu caso: status de Unicobros tipo 200/301)
          },
        },
        validations: {
          include: {
            user: { select: { name: true } },
          },
          orderBy: { timestamp: "desc" },
          take: 1,
        },
      },
    });

    if (!ticket) {
      return NextResponse.json(
        { success: false, message: "Entrada no encontrada" },
        { status: 404 },
      );
    }

    // ‚úÖ Verificar si ya fue validada
    const alreadyValidated =
      ticket.status === "VALIDATED" || !!ticket.validatedAt;

    if (alreadyValidated) {
      return NextResponse.json(
        {
          success: false,
          message: "Esta entrada ya fue utilizada",
          ticket: {
            id: ticket.id,
            orderNumber: ticket.order.orderNumber,
            buyerName: ticket.order.buyerName,
            buyerEmail: ticket.order.buyerEmail,
            buyerDNI: ticket.order.buyerDNI,
            quantity: ticket.order.quantity,
            validated: true,
            validatedAt: ticket.validatedAt,
            validatedBy: ticket.validations[0]?.user || null,
          },
        },
        { status: 400 },
      );
    }

    // ‚úÖ Verificar estado de pago (caso REAL: pago pendiente)
    if (ticket.order.paymentStatus !== "COMPLETED") {
      return NextResponse.json(
        {
          success: false,
          error: "PAYMENT_PENDING",
          message: "Pago a√∫n no confirmado. Esper√° unos segundos y reintent√°.",
          ticket: {
            id: ticket.id,
            orderNumber: ticket.order.orderNumber,
            buyerName: ticket.order.buyerName,
            buyerEmail: ticket.order.buyerEmail,
            buyerDNI: ticket.order.buyerDNI,
            quantity: ticket.order.quantity,
            validated: false,
          },
          payment: {
            paymentStatus: ticket.order.paymentStatus,
            providerStatus: ticket.order.mercadoPagoStatus, // 200/301 en Unicobros
          },
        },
        { status: 409 },
      );
    }

    // ‚úÖ TRANSACCI√ìN: update ticket + create validation (todo o nada)
    const { updatedTicket, validation } = await prisma.$transaction(
      async (tx) => {
        const updatedTicket = await tx.ticket.update({
          where: { id: ticket.id },
          data: {
            validatedAt: new Date(),
            status: "VALIDATED",
          },
          include: {
            order: {
              select: {
                orderNumber: true,
                buyerName: true,
                buyerEmail: true,
                buyerPhone: true,
                buyerDNI: true,
                unitPrice: true,
                quantity: true,
              },
            },
          },
        });

        const validation = await tx.validation.create({
          data: {
            ticketId: updatedTicket.id,
            userId: session.user.id,
            ipAddress:
              req.headers.get("x-forwarded-for") ||
              req.headers.get("x-real-ip") ||
              "unknown",
            userAgent: req.headers.get("user-agent") || "unknown",
          },
          include: {
            user: { select: { name: true } },
          },
        });

        return { updatedTicket, validation };
      },
    );

    return NextResponse.json({
      success: true,
      message: "Entrada validada correctamente",
      ticket: {
        id: updatedTicket.id,
        orderNumber: updatedTicket.order.orderNumber,
        buyerName: updatedTicket.order.buyerName,
        buyerEmail: updatedTicket.order.buyerEmail,
        buyerDNI: updatedTicket.order.buyerDNI,
        quantity: updatedTicket.order.quantity,
        validated: true,
        validatedAt: updatedTicket.validatedAt,
        validatedBy: validation.user,
      },
    });
  } catch (error) {
    console.error("Error validating ticket:", error);
    return NextResponse.json(
      {
        success: false,
        message: "Error interno del servidor",
        error: String(error),
      },
      { status: 500 },
    );
  }
}
"use client";

import { useEffect, useRef, useState } from "react";
import { Html5Qrcode } from "html5-qrcode";
import { Camera, CameraOff, AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";

interface QRScannerProps {
  onScan: (decodedText: string) => void;
  onError?: (error: string) => void;
}

export function QRScanner({ onScan, onError }: QRScannerProps) {
  const [isScanning, setIsScanning] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const scannerRef = useRef<Html5Qrcode | null>(null);
  const qrCodeRegionId = "qr-reader";

  const startScanning = async () => {
    try {
      setError(null);

      const html5QrCode = new Html5Qrcode(qrCodeRegionId);
      scannerRef.current = html5QrCode;

      // Configuraci√≥n optimizada para m√≥viles
      const config = {
        fps: 10,
        qrbox: (viewfinderWidth: number, viewfinderHeight: number) => {
          const minEdge = Math.min(viewfinderWidth, viewfinderHeight);
          const qrboxSize = Math.floor(minEdge * 0.8);
          return {
            width: qrboxSize,
            height: qrboxSize,
          };
        },
        aspectRatio: 1.0,
      };

      await html5QrCode.start(
        { facingMode: "environment" },
        config,
        (decodedText) => {
          onScan(decodedText);
          stopScanning();
        },
        (errorMessage) => {
          // Ignorar errores de escaneo continuo
        },
      );

      setIsScanning(true);
    } catch (err) {
      const errorMsg =
        err instanceof Error ? err.message : "Error al iniciar la c√°mara";
      setError(errorMsg);
      if (onError) onError(errorMsg);
    }
  };

  const stopScanning = async () => {
    if (scannerRef.current && isScanning) {
      try {
        await scannerRef.current.stop();
        scannerRef.current.clear();
      } catch (err) {
        console.error("Error stopping scanner:", err);
      }
      setIsScanning(false);
    }
  };

  useEffect(() => {
    return () => {
      stopScanning();
    };
  }, []);

  return (
    <div className="space-y-4">
      <div
        id={qrCodeRegionId}
        className="rounded-xl overflow-hidden border-4 border-purple-300 bg-gray-900 mx-auto"
        style={{
          minHeight: "250px",
          maxWidth: "100%",
        }}
      />

      {error && (
        <div className="bg-red-50 border-2 border-red-300 rounded-lg p-4">
          <div className="flex items-start gap-3">
            <AlertCircle className="h-5 w-5 text-red-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-red-900 text-sm font-semibold">{error}</p>
              <p className="text-red-700 text-xs mt-1">
                Aseg√∫rate de permitir el acceso a la c√°mara en tu navegador
              </p>
            </div>
          </div>
        </div>
      )}

      <div className="flex gap-2">
        {!isScanning ? (
          <Button
            onClick={startScanning}
            className="w-full h-14 text-base font-semibold bg-purple-600 hover:bg-purple-700"
            size="lg"
          >
            <Camera className="mr-2 h-5 w-5" />
            Iniciar C√°mara
          </Button>
        ) : (
          <Button
            onClick={stopScanning}
            variant="destructive"
            className="w-full h-14 text-base font-semibold"
            size="lg"
          >
            <CameraOff className="mr-2 h-5 w-5" />
            Detener C√°mara
          </Button>
        )}
      </div>

      {isScanning && (
        <div className="bg-blue-50 border-2 border-blue-300 rounded-lg p-4">
          <p className="text-sm text-blue-900 text-center font-medium">
            üì± Apunta la c√°mara al c√≥digo QR
          </p>
        </div>
      )}
    </div>
  );
}
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id          String       @id @default(cuid())
  email       String       @unique
  name        String
  password    String
  role        Role         @default(OPERATOR)
  active      Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  auditLogs   AuditLog[]
  validations Validation[]

  @@index([email])
}

model Order {
  id                String        @id @default(cuid())
  orderNumber       String        @unique
  buyerName         String
  buyerEmail        String
  buyerPhone        String?
  buyerDNI          String?
  unitPrice         Decimal       @db.Decimal(10, 2)
  quantity          Int
  totalAmount       Decimal       @db.Decimal(10, 2)
  paymentStatus     PaymentStatus @default(PENDING)
  mercadoPagoId     String?       @unique
  mercadoPagoStatus String?
  status            OrderStatus   @default(ACTIVE)
  purchaseDate      DateTime      @default(now())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  downloadToken     String?       @unique
  tickets           Ticket[]

  @@index([buyerEmail])
  @@index([buyerPhone])
  @@index([buyerDNI])
  @@index([orderNumber])
  @@index([mercadoPagoId])
  @@index([paymentStatus])
  @@index([downloadToken])
}

model Ticket {
  id          String       @id @default(cuid())
  code        String       @unique
  qrHash      String       @unique
  status      TicketStatus @default(PENDING_PAYMENT)
  validatedAt DateTime?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  orderId     String
  order       Order        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  validations Validation[]

  @@index([orderId])
  @@index([qrHash])
  @@index([code])
  @@index([status])
}

model SystemConfig {
  id             String   @id @default(cuid())
  ticketPrice    Decimal  @db.Decimal(10, 2)
  totalAvailable Int
  maxPerPurchase Int      @default(10)
  salesEnabled   Boolean  @default(true)
  eventDate      DateTime
  eventName      String
  eventLocation  String?
  emailFrom      String?
  emailEnabled   Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("system_config")
}

model Validation {
  id        String   @id @default(cuid())
  ticketId  String
  userId    String
  timestamp DateTime @default(now())
  ipAddress String?
  userAgent String?
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([userId])
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  userName  String
  userEmail String
  action    String
  entity    String
  entityId  String?
  oldValue  String?
  newValue  String?
  ipAddress String?
  userAgent String?
  timestamp DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([action])
  @@index([entity])
  @@index([timestamp])
}

enum Role {
  ADMIN
  OPERATOR
  VIEWER
}

enum OrderStatus {
  ACTIVE
  CANCELLED
}

enum TicketStatus {
  PENDING_PAYMENT
  PAID
  VALIDATED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}
// src/lib/qr.ts

import QRCode from "qrcode";
import crypto from "crypto";

/**
 * Genera un hash seguro para el c√≥digo QR
 */
export function generateSecureHash(ticketId: string): string {
  const salt = process.env.QR_SALT || "carnaval-2026-secret-salt";
  const hash = crypto
    .createHash("sha256")
    .update(`${ticketId}-${salt}`)
    .digest("hex");
  return hash.substring(0, 32).toUpperCase();
}

/**
 * Genera un c√≥digo QR alfanum√©rico √∫nico
 */
export function generateQRCodeString(ticketId: string): string {
  const hash = generateSecureHash(ticketId);
  const timestamp = Date.now().toString(36).toUpperCase();
  return `CV25-${hash.substring(0, 12)}-${timestamp}`;
}

/**
 * Verifica si un c√≥digo QR es v√°lido
 */
export function validateQRCode(qrCode: string): boolean {
  // Formato: CV25-XXXXXXXXXXXX-XXXXXXXX
  const pattern = /^CV25-[A-Z0-9]{12}-[A-Z0-9]+$/;
  return pattern.test(qrCode);
}

export interface QRCodeOptions {
  width?: number;
  errorCorrectionLevel?: "L" | "M" | "Q" | "H";
  margin?: number;
  color?: {
    dark?: string;
    light?: string;
  };
}

/**
 * Genera una imagen QR en formato Data URL (base64)
 */
export async function generateQRImage(
  data: string,
  options: QRCodeOptions = {},
): Promise<string> {
  const defaultOptions: QRCodeOptions = {
    width: 500,
    errorCorrectionLevel: "H", // Alta correcci√≥n de errores
    margin: 2,
    color: {
      dark: "#000000",
      light: "#FFFFFF",
    },
    ...options,
  };

  try {
    const dataUrl = await QRCode.toDataURL(data, defaultOptions);
    return dataUrl;
  } catch (error) {
    console.error("Error generating QR code:", error);
    throw new Error("Failed to generate QR code");
  }
}

/**
 * Genera una imagen QR con informaci√≥n del ticket
 * Incluye el c√≥digo QR y datos visuales
 */
export async function generateTicketQR(ticketData: {
  qrCode: string;
  orderNumber: string;
  buyerName: string;
  eventName?: string;
}): Promise<string> {
  // Genera el QR code b√°sico
  const qrDataUrl = await generateQRImage(ticketData.qrCode, {
    width: 400,
    errorCorrectionLevel: "H",
  });

  // Retorna el data URL del QR
  // En una implementaci√≥n m√°s completa, podr√≠as usar Canvas
  // para agregar el logo y texto adicional
  return qrDataUrl;
}

/**
 * Convierte un Data URL a Buffer (para enviar por email o guardar)
 */
export function dataURLtoBuffer(dataUrl: string): Buffer {
  const base64Data = dataUrl.replace(/^data:image\/\w+;base64,/, "");
  return Buffer.from(base64Data, "base64");
}

/**
 * Genera m√∫ltiples QR codes para una orden con varias entradas
 */
export async function generateMultipleQRs(
  tickets: Array<{
    id: string;
    qrCode: string;
    orderNumber: string;
    buyerName: string;
  }>,
): Promise<Array<{ ticketId: string; qrImage: string }>> {
  const results = await Promise.all(
    tickets.map(async (ticket) => {
      const qrImage = await generateTicketQR({
        qrCode: ticket.qrCode,
        orderNumber: ticket.orderNumber,
        buyerName: ticket.buyerName,
        eventName: "Carnavales 2026",
      });

      return {
        ticketId: ticket.id,
        qrImage,
      };
    }),
  );

  return results;
}
import crypto from "crypto";

const SALT = process.env.QR_SALT || "carnaval-secret-salt-2026";

/**
 * Genera un hash √∫nico para el QR del ticket
 */
export async function generateQRHash(
  orderId: string,
  ticketIndex: number,
): Promise<string> {
  const data = `${orderId}-${ticketIndex}-${Date.now()}`;
  const hash = crypto.createHmac("sha256", SALT).update(data).digest("hex");

  return hash.substring(0, 32).toUpperCase();
}

/**
 * Genera un c√≥digo legible para el ticket (para ingreso manual)
 */
export function generateReadableCode(
  orderNumber: string,
  index: number,
): string {
  // Extraer parte del orderNumber
  const parts = orderNumber.split("-");
  const timestamp = parts[1]
    ? parts[1].substring(0, 6)
    : Date.now().toString(36).substring(0, 6);
  const random = parts[2] || Math.random().toString(36).substring(2, 6);

  return `${timestamp}-${random}-${(index + 1).toString().padStart(2, "0")}`.toUpperCase();
}

/**
 * Verifica la integridad de un c√≥digo QR
 */
export function verifyQRCode(qrCode: string): boolean {
  // Verificar formato b√°sico
  if (!qrCode || qrCode.length !== 32) {
    return false;
  }

  // Verificar que solo contenga caracteres hexadecimales
  return /^[0-9A-F]+$/.test(qrCode);
}
import type { Metadata, Viewport } from "next";

export const metadata: Metadata = {
  title: "Validador QR - Carnaval Makall√©",
  description: "Aplicaci√≥n de validaci√≥n de entradas",
  manifest: "/manifest.json",
  appleWebApp: {
    capable: true,
    statusBarStyle: "black-translucent",
    title: "Validador QR",
  },
  formatDetection: {
    telephone: false,
  },
};

export const viewport: Viewport = {
  width: "device-width",
  initialScale: 1,
  maximumScale: 1,
  userScalable: false,
  themeColor: "#9333ea",
};

export default function OperadorLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  const path = request.nextUrl.pathname;

  // Rutas p√∫blicas que NO necesitan autenticaci√≥n
  const publicPaths = [
    "/",
    "/checkout",
    "/admin/login",
    "/operador/login",
    "/api",
  ];

  const response = NextResponse.next();

  // Agregar pathname a los headers
  response.headers.set("x-pathname", path);

  // Si es una ruta p√∫blica, permitir acceso
  if (publicPaths.some((publicPath) => path.startsWith(publicPath))) {
    return response;
  }

  // Para rutas protegidas, verificar el token de NextAuth
  const token =
    request.cookies.get("next-auth.session-token") ||
    request.cookies.get("__Secure-next-auth.session-token");

  // Redirigir seg√∫n la ruta
  if (!token) {
    if (path.startsWith("/admin")) {
      const loginUrl = new URL("/admin/login", request.url);
      loginUrl.searchParams.set("callbackUrl", path);
      return NextResponse.redirect(loginUrl);
    }

    if (path.startsWith("/operador")) {
      const loginUrl = new URL("/operador/login", request.url);
      loginUrl.searchParams.set("callbackUrl", path);
      return NextResponse.redirect(loginUrl);
    }
  }

  return response;
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { prisma } from "./prisma";
import { verifyPassword } from "./password";

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error("Credenciales inv√°lidas");
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user || !user.active) {
          throw new Error("Usuario no encontrado o inactivo");
        }

        const isValid = await verifyPassword(
          credentials.password,
          user.password,
        );

        if (!isValid) {
          throw new Error("Contrase√±a incorrecta");
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        };
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      if (token && session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
      }
      return session;
    },
  },
  pages: {
    signIn: "/admin/login",
  },
  session: {
    strategy: "jwt",
  },
  secret: process.env.NEXTAUTH_SECRET,
};
